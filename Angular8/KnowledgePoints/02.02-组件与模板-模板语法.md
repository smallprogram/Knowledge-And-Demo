# 目录 <!-- omit in toc --> 

# 模板语法
Angular 应用管理着**用户之所见和所为**，并通过 **Component 类的实例（组件）**和**面向用户的模板交互**来实现这一点。  
在 Angular 中，**组件**扮演着**控制器或视图模型**的角色，**模板则扮演视图**的角色。  

## 模板中的HTML
几乎所有的 HTML 语法都是有效的模板语法。  
**`<script>` 元素，它被禁用了**，以阻止脚本注入攻击的风险。（实际上，`<script> `只是被忽略了。）  
**`<html>、<body> 和 <base>` 元素并没有扮演有用的角色**。剩下的所有元素基本上就都一样用了。  

## 插值表达式与模板表达式
### 插值表达式{{...}}
插值表达式会**用双花括号 {{和 }} 作为分隔符**。例如  
```html
<h3>Current customer: {{ currentCustomer }}</h3>
```
插值表达式可以把计算后的字符串插入到 HTML 元素标签内的文本或对标签的属性进行赋值。  
```html
<p>{{title}}</p>
<div><img src="{{itemImageUrl}}"></div>
```
在**括号之间的“素材”**，通常**是组件属性的名字**。Angular 会用组件中**相应属性的字符串值**，替换这个名字。  
括号间的素材是一个**模板表达式**，Angular 先**对它求值**，**再**把它**转换成字符串**。   
```html
<!-- "The sum of 1 + 1 is 2" -->
<p>The sum of 1 + 1 is {{1 + 1}}.</p>
```
>**插值其实是一个特殊语法，Angular 会把它转换为属性绑定**。  
>想用别的分隔符来代替 {{ 和 }}，也可以通过 Component 元数据中的 interpolation 选项来配置插值分隔符。  

### 模板表达式
**模板表达式会产生一个值**，并出**现在双花括号 {{ }} 中**。  Angular 执行这个表达式，并把它**赋值给绑定目标的属性**，这个**绑定目标可能是 HTML 元素、组件或指令**。  
模板表达式禁止使用具有或可能引发副作用的 JavaScript 表达式，包括：
- 赋值 (=, +=, -=, ...)

- new、typeof、instanceof 等操作符。

- 使用 ; 或 , 串联起来的表达式

- 自增和自减运算符：++ 和 --

- 一些 ES2015+ 版本的操作符

### 表达式上下文
典型的表**达式上下文就是这个组件实例**，它是各种绑定值的来源。  
表达式的上下文**可以包括组件之外的对象**。 比如模**板输入变量 (let customer)和模板引用变量(#customerInput)就**是备选的上下文对象之一。
```html
<!-- 组件实例的表达式上下文-->
<h4>{{recommended}}</h4>
<img [src]="itemImageUrl2">

<!-- 板输入变量的表达式上下文-->
<ul>
  <li *ngFor="let customer of customers">{{customer.name}}</li>
</ul>

<!-- 模板引用变量的表达式上下文-->
<label>Type something:
  <input #customerInput>{{customerInput.value}}
</label>
```
表达式上下文变量是由**模板变量**、**指令的上下文变量**（如果有）和**组件的成员**叠加而成的。  
在同一命名空间下优先级顺序如下：
**模板变量 > 指令的上下文变量 > 组件的成员**  
如果变量命名冲突，就以以上优先级进行调用。  

> 模板表达式不能引用全局命名空间中的任何东西，比如 window 或 document。它们也不能调用 console.log 或 Math.max。 它们只能引用表达式上下文中的成员。

### 模板表达式使用指南
遵循如下规则：
- 没有可见的副作用

- 执行迅速

- 非常简单

#### 没有可见的副作用
**模板表达式除了目标属性的值以外，不应该改变应用的任何状态。**
最好使用幂等的表达式，因为它没有副作用，并且能提升 Angular 变更检测的性能。  
幂等的表达式应该总是返回完全相同的东西，直到某个依赖值发生改变。  
#### 执行迅速
**表达式应该快速结束**，否则用户就会感到拖沓，特别是在较慢的设备上。 
#### 非常简单
虽然也可以写复杂的模板表达式，不过最好避免那样做。  
属性名或方法调用应该是常态，但偶然使用逻辑取反 ! 也是可以的。 其它情况下，**应该把应用程序和业务逻辑限制在组件中**，这样它才能更容易开发和测试。  

## 模板语句
**模板语句**用来**响应由绑定目标（如 HTML 元素、组件或指令）触发的事件**。 模板语句将在事件绑定一节看到，**它出现在 = 号右侧的引号中**，就像这样：**(event)="statement"**。   
**模板语句有副作用**。 这是事件处理的关键。因为你要根据用户的输入更新应用状态。  
```html
<button (click)="deleteHero()">Delete hero</button>
``` 
**模板语句**使用的语言也像 JavaScript。 **模板语句解析器**和模板表达式解析器有所不同，特别之处在于它支持**基本赋值 (=) 和表达式链 (; 和 ,)**。

然而，某些 JavaScript 语法仍然是不允许的：
- new 运算符

- 自增和自减运算符：++ 和 --

- 操作并赋值，例如 += 和 -=

- 位操作符 | 和 &

- 模板表达式运算符
### 语句上下文
语句上下文，通常是**正在绑定事件的那个组件实例**。  
**(click)="deleteHero()"** 中的 **deleteHero** 就是这个数据绑定组件上的一个方法。  
```html
<button (click)="deleteHero()">Delete hero</button>
```

**语句上下文**可以**引用模板自身上下文中的属性**。 在下面的例子中，就把模板的 $event 对象、模板输入变量 (let hero)和模板引用变量 (#heroForm)传给了组件中的一个事件处理器方法。  

```html
<button (click)="onSave($event)">Save</button>
<button *ngFor="let hero of heroes" (click)="deleteHero(hero)">{{hero.name}}</button>
<form #heroForm (ngSubmit)="onSubmit(heroForm)"> ... </form>
```
**模板上下文中的变量优先级 > 组件上下文中的变量**

### 语句指南
和表达式一样，**避免写复杂的模板语句**。 常规是函数调用或者属性赋值。

## 绑定语法概览
绑定的类型可以根据数据流的方向分成**三类**： **从数据源到视图**、**从视图到数据源**以及**双向的从视图到数据源再到视图**。

|数据方向|语法|绑定类型|
|-|-|-|
|单向从数据源到视图|`{{expression}}`<br> `[target]="expression"`<br> `bind-target="expression"` |插值、属性Attribute、CSS类|
|从视图到数据源的单向绑定|`(target)="statement"`<br>`on-target="statement"`|事件|
|双向|`[(target)]="expression"`<br>`bindon-target="expression"`|双向|

> 由于 HTML attribute 和 DOM property 在中文中都被翻译成了“属性”，无法区分,如果**提到“属性”**的地方，一定是**指DOM property**，Angular很少操作HTML Attribute

**在等号左边是目标名， 无论是包在括号中 ([]、()) 还是用前缀形式 (bind-、on-、bindon-) 。**

**这个目标名就是属性（Property）的名字。而不是元素属性（Attribute）的名字。**

